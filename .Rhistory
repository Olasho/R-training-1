a <- 5 + 10
print(a)
a
print(a)
print(a)
a
b <- 10 * 6 + 5
b
getwd()
# We are going to create a list of the arrays we created earlier
first_list <- list(, array1, array2, array3)
knitr::opts_chunk$set(comment = "--", warning = FALSE)
# Assigning the result of an arithmetic calculation to an object named 'a'
a <- 5 + 10
# Displaying the value stored in the 'a' object
print(a)
# Alternatively, simply typing the object name also displays its value
a
# Below is a floating or double numeric data
num1 <- 3.15
# Below is an integer numeric data
num2 <- 2
# You can use class to check what type of data you have
class(num1)
char <- "hi"
logic <- TRUE
factor <- factor(c("low", "medium", "high"))
# To see what value factors as assigned to each level, you can use str
str(factor)
date <- as.Date("2023-12-31")
time <- as.POSIXct("2023-12-31 12:00:00")
# Using str to check the data type
str(date)
str(time)
# Numeric vector (integer)
vector1 <- c(1, 2, 3, 4, 5)
# Numeric vector (folating numbers)
vector2 <- c(1.43, 5.45, 6.98)
# Character vector
character_vector <- c("Diamond", "Gold", "Silver")
# Logical vector
logical_vector <- c(TRUE, FALSE, TRUE, FALSE)
# Factor vector representing categorical data
factor_vector <- factor(c("Agree", "strongly agree", "diagree", "strongly disagree"))
# Create a 3x3 matrix with numeric values
matrix1 <- matrix(data = c(1, 2, 3, 4, 5, 6, 7, 8, 9), nrow = 3, ncol = 3)
matrix1
# Create a 2x4 matrix with character values
matrix2 <- matrix(data = c("a", "b", "c", "d", "e", "f", "g", "h"), nrow = 2, ncol = 4)
matrix2
# Create a 2x2 matrix with logical values
matrix3 <- matrix(data = c(TRUE, FALSE, FALSE, TRUE), nrow = 2, ncol = 2)
matrix3
# Create a 3-dimensional array with numeric values
array1 <- array(data = c(1, 2, 3, 4, 5, 6, 7, 8, 9), dim = c(3, 3, 2))
array1
# Create a 2-dimensional array with character values
array2 <- array(data = c("a", "b", "c", "d", "e", "f"), dim = c(2, 3))
array2
# Create a 4-dimensional array with logical values
array3 <- array(data = c(TRUE, FALSE, TRUE, FALSE), dim = c(2, 2, 2, 2))
array3
# Access element at row 2, column 3, and "depth" 1
array1[2, 3, 1]
# Access the entire second "layer" of the array
array2[2, 3]
# We are going to create a list of the arrays we created earlier
first_list <- list(, array1, array2, array3)
knitr::opts_chunk$set(comment = "--", warning = FALSE)
# Assigning the result of an arithmetic calculation to an object named 'a'
a <- 5 + 10
# Displaying the value stored in the 'a' object
print(a)
# Alternatively, simply typing the object name also displays its value
a
# Below is a floating or double numeric data
num1 <- 3.15
# Below is an integer numeric data
num2 <- 2
# You can use class to check what type of data you have
class(num1)
char <- "hi"
logic <- TRUE
factor <- factor(c("low", "medium", "high"))
# To see what value factors as assigned to each level, you can use str
str(factor)
date <- as.Date("2023-12-31")
time <- as.POSIXct("2023-12-31 12:00:00")
# Using str to check the data type
str(date)
str(time)
# Numeric vector (integer)
vector1 <- c(1, 2, 3, 4, 5)
# Numeric vector (folating numbers)
vector2 <- c(1.43, 5.45, 6.98)
# Character vector
character_vector <- c("Diamond", "Gold", "Silver")
# Logical vector
logical_vector <- c(TRUE, FALSE, TRUE, FALSE)
# Factor vector representing categorical data
factor_vector <- factor(c("Agree", "strongly agree", "diagree", "strongly disagree"))
# Create a 3x3 matrix with numeric values
matrix1 <- matrix(data = c(1, 2, 3, 4, 5, 6, 7, 8, 9), nrow = 3, ncol = 3)
matrix1
# Create a 2x4 matrix with character values
matrix2 <- matrix(data = c("a", "b", "c", "d", "e", "f", "g", "h"), nrow = 2, ncol = 4)
matrix2
# Create a 2x2 matrix with logical values
matrix3 <- matrix(data = c(TRUE, FALSE, FALSE, TRUE), nrow = 2, ncol = 2)
matrix3
# Create a 3-dimensional array with numeric values
array1 <- array(data = c(1, 2, 3, 4, 5, 6, 7, 8, 9), dim = c(3, 3, 2))
array1
# Create a 2-dimensional array with character values
array2 <- array(data = c("a", "b", "c", "d", "e", "f"), dim = c(2, 3))
array2
# Create a 4-dimensional array with logical values
array3 <- array(data = c(TRUE, FALSE, TRUE, FALSE), dim = c(2, 2, 2, 2))
array3
# Access element at row 2, column 3, and "depth" 1
array1[2, 3, 1]
# Access the entire second "layer" of the array
array2[2, 3]
# We are going to create a list of the arrays we created earlier
first_list <- list(, array1, array2, array3)
# We are going to create a list of the arrays we created earlier
first_list <- list(array1, array2, array3)
first_list
element_1 <- first_list[[1]]
element_1
remove(element_1)
b <- c(1, 2, 3, 4, 5, 6, 7, 8)
list[[4]] <- b
b <- c(1, 2, 3, 4, 5, 6, 7, 8)
list[[4]] <- b
b
first_list[[]] <- b
first_list[[4]] <- b
first_list
# looking at the list
remove(first_list)
# We are going to create a list of the arrays we created earlier
list_first <- list(array1, array2, array3)
# Seeing what the output looks like
list_first
# Accessing elements from the list created above
object_1 <- list_first[[1]]
object_1
# let us create a vector
b <- c(1, 2, 3, 4, 5, 6, 7, 8)
# adding the vector to the list
list_first[[4]] <- b
# looking at the list
list_first
# let us create anothe list
## first creating random vectors
a <- c("sun", "star", "moon")
c <- c(1, 2, 3, 4, 5)
d <- c("earth", "mars", "venus")
list_combine <- c(list_first, list_second)
list_second <- c(a, c, d)
list_combine <- c(list_first, list_second)
list_combine
list_second <- list(a, c, d)
list_combine <- c(list_first, list_second)
list_combine
Titanic
iris
head(iris)
View(iris)
The "iris" dataset contains 150 rows and several columns, which could occupy considerable space in our training material. To keep it concise, I've used the **head()** function to display only the first 6 rows of the dataset. However, for a comprehensive view of the entire dataset, a better approach is to utilize the **view()** function. This function opens a separate window or tab displaying the entire dataset, allowing for a more detailed examination. Let's try it out below.
